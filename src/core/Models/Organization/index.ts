import { Schema, model, connect, Types } from 'mongoose';
import { IUser, UserRole, UserEntity } from '../User/IUser';
import * as q from "q";
import * as env from './../../../../config/env.json';
import * as bcrypt from "bcrypt";
import * as jwt from 'jsonwebtoken';
import Message from "../../Util/Message";
import {getDBConnectionURL} from "../../Util/db";
import * as mongoosePaginate from "mongoose-paginate";
import * as softDelete from "mongoose-delete";
import { IPaginatedModel } from "../IPaginatedModel";
import * as moment from  "moment";
import * as json5 from "json5"
import {ServiceProvider} from '../ServiceProvider';
import {Customer} from '../Customer';
import {SubCustomer} from '../SubCustomer';
import {Asset }from '../Asset';
import { Device } from '../Device';
import { UserRoles } from '../UserRoles';
import GomosLogger from '../../Util/commanUtill/GomosLogger';
import G from '../../Util/commanUtill/gConstant';
import { IOrganization } from './IOrganization';
var httpRequest = require('request');

var AES = require("crypto-js/aes");
var CryptoJS = require("crypto-js");

var secret_key =    "anf123k5md78kr39ktnf94jthrJJHJ89";

connect(getDBConnectionURL(),{ useNewUrlParser: true }) 
const expiresIn  = '1d';

export var OrganizationSchema:Schema      =   new Schema({
    organizationId: {
        type: Types.ObjectId
    },
    name: {
        type: String
    },
},
{
    timestamps: { createdAt: 'createdTime', updatedAt: 'updatedTime' }
});

OrganizationSchema.plugin(softDelete);
OrganizationSchema.plugin(mongoosePaginate);

OrganizationSchema.set('toJSON', {
    transform: function(doc, ret, options) {
        delete ret.password;
        return ret;
    }
});

OrganizationSchema.pre('save',(next)=>{
    let now     =   new Date();
    if(!this.createdTime){
        this.createdTime  = now;
    } else {
        this.updatedTime  =   now;
    }
    return next();
});

OrganizationSchema.methods.getUserOrganizationIdBasedList  = async function(user: IUser){
    let defer   =   q.defer();
    try {
    var user    =   user;
    var result1= []
    var result= []
    var tempId= [];
    var tempId2= []
    var subCustomerData =[]
    var CustomerData =[]
    switch(user.userEntity){
        case UserEntity.PLATFORM :
             console.log("this is called", UserEntity.PLATFORM );
            result1 =  await  Organization.find({});
            result1.map(item => {result.push(item)})
            let result2 =  await ServiceProvider.find({});
            result2.map(item=> {result.push(item)})
            tempId = result2.map(item => item._id);
            CustomerData =  await Customer.find({"spId" : {"$in": tempId}});
            CustomerData.map(item => {result.push(item)})
              tempId2 = CustomerData.map(item => item._id);
             subCustomerData =  await SubCustomer.find({"custId": { "$in": tempId2}});
            subCustomerData.map(item => {result.push(item)})
            console.log("this is called", result);
             defer.resolve(new Message(Message.SUCCESS, "organizationId",  result));
            break;
        case UserEntity.SERVICE_PROVIDER:
            //  console.log("this is called", UserEntity.SERVICE_PROVIDER );
            result =  await ServiceProvider.find({"_id" : user.organizationId});
            tempId = result.map(item => item._id);
            CustomerData =  await Customer.find({"spId" : {"$in": tempId}});
            CustomerData.map(item => {result.push(item)})
              tempId2 = CustomerData.map(item => item._id);
             subCustomerData =  await SubCustomer.find({"custId": { "$in": tempId2}});
            subCustomerData.map(item => {result.push(item)})
             defer.resolve(new Message(Message.SUCCESS, "organizationId",  result));
             break;
        case UserEntity.CLIENT:
            //  console.log("this is called", UserEntity.CLIENT );
              result =  await Customer.find({"_id" : user.organizationId});
               tempId = result.map(item => item._id);
               subCustomerData =  await SubCustomer.find({"custId": { "$in": tempId}});
              subCustomerData.map(item => {result.push(item)})

             defer.resolve(new Message(Message.SUCCESS, "organizationId", result));
             break;    
       case UserEntity.SUB_CUSTOMER:
             result =  await SubCustomer.find({"_id": user.organizationId})
            defer.resolve(new Message(Message.SUCCESS, "organizationId",  result));
            break;       

    }
}
    catch (error) {
        defer.reject(new Message(Message.INTERNAL_ERROR, "This is error generated by UserSchema.methods.getUserOrganizationIdBasedList ", []));
    }


    return defer.promise;
}



export const Organization: IPaginatedModel<IOrganization> = model<IOrganization>("Organization", OrganizationSchema,"Organization");